package hw6;

import java.util.*;

import hw5.*;
import hw6.MarvelParser.MalformedDataException;

/**
 * 
 * This client program is for the use of searching for a 'path' between
 * two characters to see how they are connected. Paths are found via BFS
 * search. 
 *
 */
public class MarvelPaths {
	
	private static Graph marvelGraph;
	private static final String FILE_NAME = "src/hw6/data/marvel.tsv";
	
	public static void main(String[] args) {
		// Initialize the graph
		marvelGraph = new Graph();
		buildGraph(marvelGraph, FILE_NAME);
		
		// Get two character names from the user
        Scanner console = new Scanner(System.in);
        System.out.println("Welcome to the Marvel character search");
        System.out.println("Given any two character names, a connection can be searched for");
        System.out.println("What is your character one name:");
        String char1 = console.nextLine();
        System.out.println("What is your character two name: ");
        String char2 = console.nextLine();
        System.out.println(); 
        
        // Generate the path
		System.out.println(findPath(marvelGraph, char1, char2));
		console.close();
	}
	
	/**
	 * Builds a graph with nodes and edges from the given filename.
	 * 
	 * @param someGraph A graph to be added to
	 * @param fileName the file containing the information in (.tsv) format to be 
	 * added to the graph
	 */
	public static void buildGraph(Graph someGraph, String fileName) {
		Set<String> characters = new HashSet<String>();
		Map<String, List<String>> books = new HashMap<String, List<String>>();
		
		try {
			MarvelParser.parseData(fileName, characters, books);
		} catch (MalformedDataException e) {
			e.printStackTrace();
		}
		
		// add all the characters as nodes
		Iterator<String> itr = characters.iterator();
		while(itr.hasNext()) {
			String character = itr.next();
			if(character != null) {
				Node value = new Node(character);
				someGraph.addNode(value);
			}
		}
		
		// add all the edges
		for(String book : books.keySet()) {
			List<String> charList = books.get(book);
			for(int i = 0; i < charList.size() - 1; i++) {
				for(int j= i+1; j < charList.size(); j++) {
					someGraph.addEdge(new Edge(new Node(charList.get(i)), new Node(charList.get(j)), book));
					someGraph.addEdge(new Edge(new Node(charList.get(j)), new Node(charList.get(i)), book));
				}
			}
		}
	}
	
	/**
	 * Takes the names of two characters and searches for the shortest path
	 * between the two using BFS search.
	 * 
	 * @param temp the Graph to search for a path within
	 * @param char1 the starting character
	 * @param char2 the character to search for
	 * @return returns a string format of the path of character1 to character2
	 */
	public static String findPath(Graph temp, String char1, String char2) {
	    Node firstCharacter = new Node(char1);
	    Node endCharacter = new Node(char2);
	    Queue<Node> worklist = new LinkedList<Node>();
	    Map<Node, List<Edge>> nodeToPath = new HashMap<Node, List<Edge>>();
	    
	    if(!temp.containsNode(firstCharacter)) {
	    	String result = "path from " + char1 + " to " + char2 + ":";
	    	return result + System.lineSeparator() + "Unknown character: " + char1;
	    } else if(!temp.containsNode(endCharacter)) {
	    	String result = "path from " + char1 + " to " + char2 + ":";
	    	return result + System.lineSeparator() + "Unknown character: " + char2;
	    }
	   
	    worklist.add(firstCharacter);
	    nodeToPath.put(firstCharacter, new ArrayList<Edge>());
	    	   
	    // Uses BFS algorithm here
	    while(!worklist.isEmpty()) {
	    	Node current = worklist.remove();
	    	if(current.equals(endCharacter)) {
	    		return pathToString(nodeToPath.get(current), char1, char2);
	    	}
	    	for(Edge value : temp.getChildren(current)) { 
	    		Node valueChild = value.getChild(); 
	    	    if(!nodeToPath.containsKey(valueChild)) { 
	    	    	List<Edge> newPath = new ArrayList<Edge>(nodeToPath.get(current)); 
	    	    	newPath.add(value);
	    	    	nodeToPath.put(valueChild, newPath);
	    	    	worklist.add(valueChild);
	    	    }
	    	}

	    }
	    return pathToString(null, char1, char2);
	}
	
	/**
	 * Creates the string format for the path.
	 * 
	 * @param path A list of the path from character1 to character2
	 * @param char1 Starting character
	 * @param char2 Character that was searched for
	 * @return returns a string format of the path
	 */
	private static String pathToString(List<Edge> path, String char1, String char2) {
		String result = "path from " + char1 + " to " + char2 + ":";
		
		if(path == null) {
			return result + System.lineSeparator() + "no path found";
		} else if(char1.equals(char2)) {
			return result + System.lineSeparator() + "Same character";
		} else {
			String prev = char1;
			String current;
			for(int i = 1; i < path.size(); i++) {
				current = path.get(i).getParent().getData();
				result += System.lineSeparator() + prev + " to " + current + " via "
						+ path.get(i-1).getValue();
				prev = current;
			}
			String edge = path.get(path.size() - 1).getValue();
			result += System.lineSeparator() + prev + " to " + char2 + " via " + edge;
		}
		
		return result;
	}
}
