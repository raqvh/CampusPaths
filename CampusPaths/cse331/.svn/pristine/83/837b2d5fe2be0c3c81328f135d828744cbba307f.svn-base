package hw8;

import hw5.*;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;


/**
 * Parser utility to load the Campus paths data set.
 */
public class CampusPathsParser {
    /**
     * A checked exception class for bad data files
     */
    @SuppressWarnings("serial")
    public static class MalformedDataException extends Exception {
        public MalformedDataException() { }

        public MalformedDataException(String message) {
            super(message);
        }

        public MalformedDataException(Throwable cause) {
            super(cause);
        }

        public MalformedDataException(String message, Throwable cause) {
            super(message, cause);
        }
    }

  /**
   * Read the campus building data file for the UW Campus.
   * Each line of the input file contains a abbreviated name,
   * long name, and the (x,y) coords, separated by a tab character
   * 
   * ShortName    LongName    x    y
   * 
   * @requires filename is a valid file path
   * @param filename the file that will be read
   * @param buildingNames map in which all abbreviated names are mapped to
   * 		their full name. Typically empty when the routine is called
   * @param buildingCoords map from abbrev of building names to a list that
   *        has the (x,y) coords. Typically empty when the routine is called
   * @modifies buildingNames, buildingCoords
   * @effects fills buildingNames with a mapping of abbreviations to full name
   * @effects fills buildingCoords with a map from each abbreviated name to
   * 		  a list with the (x,y) coords.
   * @throws MalformedDataException if the file is not well-formed:
   *          each line contains exactly two tokens separated by a tab,
   *          or else starting with a # symbol to indicate a comment line.
   */
  public static void parseData(String filename, Graph<Coordinate,Double> buildingPaths) 
		  throws MalformedDataException {
    // Why does this method accept the Collections to be filled as
    // parameters rather than making them a return value? To allows us to
    // "return" two different Collections. If only one or neither Collection
    // needs to be returned to the caller, feel free to rewrite this method
    // without the parameters. Generally this is better style.
    BufferedReader reader = null;
    try {
        reader = new BufferedReader(new FileReader(filename));

        // Construct the collections of characters and books, one
        // <character, book> pair at a time.
        String inputLine;
        Node<Coordinate> current = null;
        while ((inputLine = reader.readLine()) != null) {

            // Ignore comment lines.
            if (inputLine.startsWith("#")) {
                continue;
            }

            // Parse the data, stripping out quotation marks and throwing
            // an exception for malformed lines.
            if (!inputLine.startsWith("\t")) {
            	
            	// This is an (x,y) coord. Split by comma to get the data.
            	String[] tokens = inputLine.split(",");
            	if (tokens.length != 2) {
            		throw new MalformedDataException("Line should contain "
            				+ "exactly one comma: " + inputLine);
            	}
            	
            	double x = Double.parseDouble(tokens[0]);
            	double y = Double.parseDouble(tokens[1]);
            	current = new Node<Coordinate>(new Coordinate(x,y));
            	buildingPaths.addNode(current);
            	
            } else {
            	
            	if(current == null) {
            		throw new MalformedDataException("First line should have not been tabbed");
            	}
            	inputLine.replace("\t", "");
            	//	x2,y2: distance12
            	// First parce by the : to get the coords and distance
            	String[] tokens = inputLine.split(": ");
            	if (tokens.length != 2) {
            		throw new MalformedDataException("Line should contain " 
            				+ "exactly one ': ': " + inputLine);
            	}
            	
            	// Now parse the coordinate part to get x and y
            	String[] coords = tokens[0].split(",");
            	if(coords.length != 2) {
            		throw new MalformedDataException("Line should contain "
            				+ "exactly one comma: " + inputLine);
            	}
            	
            	// Organize the data and put it into our graph
            	double x = Double.parseDouble(coords[0]);
            	double y = Double.parseDouble(coords[1]);
            	double cost = Double.parseDouble(tokens[1]);
            	
            	Node<Coordinate> newCoord = new Node<Coordinate>(new Coordinate(x,y));
            	if(!buildingPaths.containsNode(newCoord)) {
            		buildingPaths.addNode(newCoord);
            	}
            	
            	// Add edge from current to newCoord and newCoord to current (both directions)
            	buildingPaths.addEdge(new Edge<Double,Coordinate>(current, newCoord, cost));
            	buildingPaths.addEdge(new Edge<Double,Coordinate>(newCoord, current, cost));
            }
        }
    } catch (IOException e) {
        System.err.println(e.toString());
        e.printStackTrace(System.err);
    } finally {
        if (reader != null) {
            try {
                reader.close();
            } catch (IOException e) {
                System.err.println(e.toString());
                e.printStackTrace(System.err);
            }
        }
    }
  }

}